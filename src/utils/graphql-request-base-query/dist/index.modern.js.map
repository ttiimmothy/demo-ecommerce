{"version":3,"file":"index.modern.js","sources":["../src/index.ts"],"sourcesContent":["import { isPlainObject } from '@reduxjs/toolkit'\nimport type { BaseQueryFn } from '@reduxjs/toolkit/query'\nimport type { DocumentNode } from 'graphql'\nimport { GraphQLClient, ClientError, RequestOptions } from 'graphql-request'\nimport type {\n  ErrorResponse,\n  GraphqlRequestBaseQueryArgs,\n  PrepareHeaders,\n  RequestHeaders,\n} from './GraphqlBaseQueryTypes'\n\nexport const graphqlRequestBaseQuery = <E = ErrorResponse>(\n  options: GraphqlRequestBaseQueryArgs<E>\n): BaseQueryFn<\n  { document: string | DocumentNode; variables?: any },\n  unknown,\n  E,\n  Partial<Pick<ClientError, 'request' | 'response'>>\n> => {\n  const client =\n    'client' in options ? options.client : new GraphQLClient(options.url)\n  const requestHeaders: RequestHeaders =\n    'requestHeaders' in options ? options.requestHeaders : {}\n\n  return async (\n    { document, variables },\n    { getState, endpoint, forced, type, signal, extra }\n  ) => {\n    try {\n      const prepareHeaders: PrepareHeaders =\n        options.prepareHeaders ?? ((x) => x)\n      const headers = new Headers(stripUndefined(requestHeaders))\n\n      const preparedHeaders = await prepareHeaders(headers, {\n        getState,\n        endpoint,\n        forced,\n        type,\n        extra,\n      })\n\n      return {\n        data: await client.request({\n          document,\n          variables,\n          signal: signal as unknown as RequestOptions['signal'],\n          requestHeaders: preparedHeaders,\n        }),\n        meta: {},\n      }\n    } catch (error) {\n      if (error instanceof ClientError) {\n        const { name, message, stack, request, response } = error\n\n        const customErrors =\n          options.customErrors ?? (() => ({ name, message, stack }))\n\n        const customizedErrors = customErrors(error) as E\n\n        return { error: customizedErrors, meta: { request, response } }\n      }\n      throw error\n    }\n  }\n}\n\nfunction stripUndefined(obj: any) {\n  if (!isPlainObject(obj)) {\n    return obj\n  }\n  const copy: Record<string, any> = { ...obj }\n  for (const [k, v] of Object.entries(copy)) {\n    if (typeof v === 'undefined') delete copy[k]\n  }\n  return copy\n}\n"],"names":["graphqlRequestBaseQuery","options","client","url","requestHeaders","async","document","variables","getState","endpoint","forced","type","signal","extra","_options$prepareHeade","prepareHeaders","x","headers","Headers","obj","isPlainObject","copy","_extends","k","v","Object","entries","stripUndefined","data","request","preparedHeaders","meta","error","ClientError","_options$customErrors","name","message","stack","response","customErrors"],"mappings":"sVAWaA,MAAuBA,EAClCC,IAOA,MAAYC,EACV,WAAYD,EAAUA,EAAQC,OAAS,MAAkBD,EAAQE,KAC7DC,EACJ,mBAAAH,EAA8BA,EAAQG,eAAiB,GAEzD,OACEC,OAAEC,WAAUC,cACVC,WAAUC,WAAUC,SAAQC,OAAMC,SAAQC,YAE5C,IACE,IAAAC,EAAA,MAAoBC,EAAA,OAAAD,EAClBb,EAAQc,gBADUD,EACUE,GAAMA,EACvBC,EAAG,IAAIC,QAmC1B,SAAwBC,GACtB,IAAKC,EAAcD,GACjB,OACDA,EACD,MAAUE,EAAAC,EAAA,GAA6BH,GACvC,IAAK,MAAOI,EAAGC,KAAMC,OAAOC,QAAQL,QACjB,IAAbG,UAAiCH,EAAKE,GAE5C,OACDF,EA5CiCM,CAAevB,YAECW,EAACE,EAAS,CACpDT,WACAC,WACAC,SACAC,OACAE,UAGF,MAAO,CACLe,WAAY1B,EAAO2B,QAAQ,CACzBvB,WACAC,YACAK,OAAQA,EACRR,eAAgB0B,IAElBC,KAAM,IAER,MAAOC,GACP,GAAIA,aAAJC,EAAkC,CAChC,IAAAC,EAAA,MAAMC,KAAEA,EAAFC,QAAQA,EAARC,MAAiBA,EAAjBR,QAAwBA,EAAxBS,SAAiCA,GAAaN,EAOpD,MAAO,CAAEA,OAJkB,OAAzB/B,EAAAA,EAAQsC,cAAiBL,EAAA,KAAA,CAASC,OAAMC,UAASC,WAEbL,GAEJD,KAAM,CAAEF,UAASS,aAErD,MAAMN"}